
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models.js"
import { type PrismaClient } from "./class.js"

export type * from '../models.js'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.2.0
 * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
 */
export const prismaVersion: PrismaVersion = {
  client: "7.2.0",
  engine: "0c8ef2ce45c83248ab3df073180d5eda9e8be7a3"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  User: 'User',
  Session: 'Session',
  CompanyOwner: 'CompanyOwner',
  Company: 'Company',
  Employee: 'Employee',
  Permission: 'Permission',
  Role: 'Role',
  RolePermission: 'RolePermission',
  Seo: 'Seo',
  Hero: 'Hero',
  About: 'About',
  Contact: 'Contact',
  Careers: 'Careers',
  Realizations: 'Realizations',
  GalleryItem: 'GalleryItem',
  Stat: 'Stat',
  Location: 'Location',
  Service: 'Service',
  StockItem: 'StockItem',
  StockCategory: 'StockCategory',
  Supplier: 'Supplier',
  StockMovement: 'StockMovement',
  StockMovementItem: 'StockMovementItem',
  Payslip: 'Payslip',
  AccountingEntry: 'AccountingEntry',
  Quote: 'Quote',
  QuoteItem: 'QuoteItem',
  ContactCrm: 'ContactCrm',
  Deal: 'Deal',
  JobOpening: 'JobOpening',
  Invoice: 'Invoice',
  InvoiceItem: 'InvoiceItem',
  Payment: 'Payment',
  PurchaseOrder: 'PurchaseOrder',
  PurchaseOrderItem: 'PurchaseOrderItem',
  Attendance: 'Attendance',
  LeaveRequest: 'LeaveRequest',
  Task: 'Task',
  Dictionary: 'Dictionary',
  PrinterSettings: 'PrinterSettings',
  AuditLog: 'AuditLog',
  Webhook: 'Webhook',
  ApiKey: 'ApiKey',
  FileResource: 'FileResource',
  Currency: 'Currency',
  ExchangeRate: 'ExchangeRate'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "user" | "session" | "companyOwner" | "company" | "employee" | "permission" | "role" | "rolePermission" | "seo" | "hero" | "about" | "contact" | "careers" | "realizations" | "galleryItem" | "stat" | "location" | "service" | "stockItem" | "stockCategory" | "supplier" | "stockMovement" | "stockMovementItem" | "payslip" | "accountingEntry" | "quote" | "quoteItem" | "contactCrm" | "deal" | "jobOpening" | "invoice" | "invoiceItem" | "payment" | "purchaseOrder" | "purchaseOrderItem" | "attendance" | "leaveRequest" | "task" | "dictionary" | "printerSettings" | "auditLog" | "webhook" | "apiKey" | "fileResource" | "currency" | "exchangeRate"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    User: {
      payload: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.UserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    Session: {
      payload: Prisma.$SessionPayload<ExtArgs>
      fields: Prisma.SessionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SessionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        findFirst: {
          args: Prisma.SessionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        findMany: {
          args: Prisma.SessionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        create: {
          args: Prisma.SessionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        createMany: {
          args: Prisma.SessionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        delete: {
          args: Prisma.SessionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        update: {
          args: Prisma.SessionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        deleteMany: {
          args: Prisma.SessionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SessionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        upsert: {
          args: Prisma.SessionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        aggregate: {
          args: Prisma.SessionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSession>
        }
        groupBy: {
          args: Prisma.SessionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionGroupByOutputType>[]
        }
        count: {
          args: Prisma.SessionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionCountAggregateOutputType> | number
        }
      }
    }
    CompanyOwner: {
      payload: Prisma.$CompanyOwnerPayload<ExtArgs>
      fields: Prisma.CompanyOwnerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CompanyOwnerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyOwnerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CompanyOwnerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyOwnerPayload>
        }
        findFirst: {
          args: Prisma.CompanyOwnerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyOwnerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CompanyOwnerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyOwnerPayload>
        }
        findMany: {
          args: Prisma.CompanyOwnerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyOwnerPayload>[]
        }
        create: {
          args: Prisma.CompanyOwnerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyOwnerPayload>
        }
        createMany: {
          args: Prisma.CompanyOwnerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CompanyOwnerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyOwnerPayload>[]
        }
        delete: {
          args: Prisma.CompanyOwnerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyOwnerPayload>
        }
        update: {
          args: Prisma.CompanyOwnerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyOwnerPayload>
        }
        deleteMany: {
          args: Prisma.CompanyOwnerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CompanyOwnerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CompanyOwnerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyOwnerPayload>[]
        }
        upsert: {
          args: Prisma.CompanyOwnerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyOwnerPayload>
        }
        aggregate: {
          args: Prisma.CompanyOwnerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCompanyOwner>
        }
        groupBy: {
          args: Prisma.CompanyOwnerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyOwnerGroupByOutputType>[]
        }
        count: {
          args: Prisma.CompanyOwnerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyOwnerCountAggregateOutputType> | number
        }
      }
    }
    Company: {
      payload: Prisma.$CompanyPayload<ExtArgs>
      fields: Prisma.CompanyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CompanyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        findFirst: {
          args: Prisma.CompanyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        findMany: {
          args: Prisma.CompanyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>[]
        }
        create: {
          args: Prisma.CompanyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        createMany: {
          args: Prisma.CompanyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>[]
        }
        delete: {
          args: Prisma.CompanyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        update: {
          args: Prisma.CompanyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        deleteMany: {
          args: Prisma.CompanyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CompanyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>[]
        }
        upsert: {
          args: Prisma.CompanyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CompanyPayload>
        }
        aggregate: {
          args: Prisma.CompanyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCompany>
        }
        groupBy: {
          args: Prisma.CompanyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyGroupByOutputType>[]
        }
        count: {
          args: Prisma.CompanyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CompanyCountAggregateOutputType> | number
        }
      }
    }
    Employee: {
      payload: Prisma.$EmployeePayload<ExtArgs>
      fields: Prisma.EmployeeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>
        }
        findFirst: {
          args: Prisma.EmployeeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>
        }
        findMany: {
          args: Prisma.EmployeeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>[]
        }
        create: {
          args: Prisma.EmployeeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>
        }
        createMany: {
          args: Prisma.EmployeeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>[]
        }
        delete: {
          args: Prisma.EmployeeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>
        }
        update: {
          args: Prisma.EmployeeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>
        }
        deleteMany: {
          args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>[]
        }
        upsert: {
          args: Prisma.EmployeeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EmployeePayload>
        }
        aggregate: {
          args: Prisma.EmployeeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEmployee>
        }
        groupBy: {
          args: Prisma.EmployeeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmployeeGroupByOutputType>[]
        }
        count: {
          args: Prisma.EmployeeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EmployeeCountAggregateOutputType> | number
        }
      }
    }
    Permission: {
      payload: Prisma.$PermissionPayload<ExtArgs>
      fields: Prisma.PermissionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PermissionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        findFirst: {
          args: Prisma.PermissionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        findMany: {
          args: Prisma.PermissionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>[]
        }
        create: {
          args: Prisma.PermissionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        createMany: {
          args: Prisma.PermissionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>[]
        }
        delete: {
          args: Prisma.PermissionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        update: {
          args: Prisma.PermissionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        deleteMany: {
          args: Prisma.PermissionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PermissionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PermissionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>[]
        }
        upsert: {
          args: Prisma.PermissionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PermissionPayload>
        }
        aggregate: {
          args: Prisma.PermissionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePermission>
        }
        groupBy: {
          args: Prisma.PermissionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PermissionGroupByOutputType>[]
        }
        count: {
          args: Prisma.PermissionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PermissionCountAggregateOutputType> | number
        }
      }
    }
    Role: {
      payload: Prisma.$RolePayload<ExtArgs>
      fields: Prisma.RoleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RoleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        findFirst: {
          args: Prisma.RoleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        findMany: {
          args: Prisma.RoleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[]
        }
        create: {
          args: Prisma.RoleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        createMany: {
          args: Prisma.RoleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[]
        }
        delete: {
          args: Prisma.RoleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        update: {
          args: Prisma.RoleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        deleteMany: {
          args: Prisma.RoleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RoleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[]
        }
        upsert: {
          args: Prisma.RoleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>
        }
        aggregate: {
          args: Prisma.RoleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRole>
        }
        groupBy: {
          args: Prisma.RoleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RoleGroupByOutputType>[]
        }
        count: {
          args: Prisma.RoleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RoleCountAggregateOutputType> | number
        }
      }
    }
    RolePermission: {
      payload: Prisma.$RolePermissionPayload<ExtArgs>
      fields: Prisma.RolePermissionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RolePermissionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RolePermissionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        findFirst: {
          args: Prisma.RolePermissionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RolePermissionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        findMany: {
          args: Prisma.RolePermissionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
        }
        create: {
          args: Prisma.RolePermissionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        createMany: {
          args: Prisma.RolePermissionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RolePermissionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
        }
        delete: {
          args: Prisma.RolePermissionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        update: {
          args: Prisma.RolePermissionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        deleteMany: {
          args: Prisma.RolePermissionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RolePermissionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RolePermissionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>[]
        }
        upsert: {
          args: Prisma.RolePermissionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePermissionPayload>
        }
        aggregate: {
          args: Prisma.RolePermissionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRolePermission>
        }
        groupBy: {
          args: Prisma.RolePermissionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RolePermissionGroupByOutputType>[]
        }
        count: {
          args: Prisma.RolePermissionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RolePermissionCountAggregateOutputType> | number
        }
      }
    }
    Seo: {
      payload: Prisma.$SeoPayload<ExtArgs>
      fields: Prisma.SeoFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SeoFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SeoPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SeoFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SeoPayload>
        }
        findFirst: {
          args: Prisma.SeoFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SeoPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SeoFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SeoPayload>
        }
        findMany: {
          args: Prisma.SeoFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SeoPayload>[]
        }
        create: {
          args: Prisma.SeoCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SeoPayload>
        }
        createMany: {
          args: Prisma.SeoCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SeoCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SeoPayload>[]
        }
        delete: {
          args: Prisma.SeoDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SeoPayload>
        }
        update: {
          args: Prisma.SeoUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SeoPayload>
        }
        deleteMany: {
          args: Prisma.SeoDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SeoUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SeoUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SeoPayload>[]
        }
        upsert: {
          args: Prisma.SeoUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SeoPayload>
        }
        aggregate: {
          args: Prisma.SeoAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSeo>
        }
        groupBy: {
          args: Prisma.SeoGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SeoGroupByOutputType>[]
        }
        count: {
          args: Prisma.SeoCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SeoCountAggregateOutputType> | number
        }
      }
    }
    Hero: {
      payload: Prisma.$HeroPayload<ExtArgs>
      fields: Prisma.HeroFieldRefs
      operations: {
        findUnique: {
          args: Prisma.HeroFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HeroPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.HeroFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HeroPayload>
        }
        findFirst: {
          args: Prisma.HeroFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HeroPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.HeroFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HeroPayload>
        }
        findMany: {
          args: Prisma.HeroFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HeroPayload>[]
        }
        create: {
          args: Prisma.HeroCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HeroPayload>
        }
        createMany: {
          args: Prisma.HeroCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.HeroCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HeroPayload>[]
        }
        delete: {
          args: Prisma.HeroDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HeroPayload>
        }
        update: {
          args: Prisma.HeroUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HeroPayload>
        }
        deleteMany: {
          args: Prisma.HeroDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.HeroUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.HeroUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HeroPayload>[]
        }
        upsert: {
          args: Prisma.HeroUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$HeroPayload>
        }
        aggregate: {
          args: Prisma.HeroAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateHero>
        }
        groupBy: {
          args: Prisma.HeroGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HeroGroupByOutputType>[]
        }
        count: {
          args: Prisma.HeroCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.HeroCountAggregateOutputType> | number
        }
      }
    }
    About: {
      payload: Prisma.$AboutPayload<ExtArgs>
      fields: Prisma.AboutFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AboutFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AboutFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutPayload>
        }
        findFirst: {
          args: Prisma.AboutFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AboutFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutPayload>
        }
        findMany: {
          args: Prisma.AboutFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutPayload>[]
        }
        create: {
          args: Prisma.AboutCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutPayload>
        }
        createMany: {
          args: Prisma.AboutCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AboutCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutPayload>[]
        }
        delete: {
          args: Prisma.AboutDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutPayload>
        }
        update: {
          args: Prisma.AboutUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutPayload>
        }
        deleteMany: {
          args: Prisma.AboutDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AboutUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AboutUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutPayload>[]
        }
        upsert: {
          args: Prisma.AboutUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AboutPayload>
        }
        aggregate: {
          args: Prisma.AboutAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAbout>
        }
        groupBy: {
          args: Prisma.AboutGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AboutGroupByOutputType>[]
        }
        count: {
          args: Prisma.AboutCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AboutCountAggregateOutputType> | number
        }
      }
    }
    Contact: {
      payload: Prisma.$ContactPayload<ExtArgs>
      fields: Prisma.ContactFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ContactFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>
        }
        findFirst: {
          args: Prisma.ContactFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>
        }
        findMany: {
          args: Prisma.ContactFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>[]
        }
        create: {
          args: Prisma.ContactCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>
        }
        createMany: {
          args: Prisma.ContactCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>[]
        }
        delete: {
          args: Prisma.ContactDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>
        }
        update: {
          args: Prisma.ContactUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>
        }
        deleteMany: {
          args: Prisma.ContactDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ContactUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ContactUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>[]
        }
        upsert: {
          args: Prisma.ContactUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactPayload>
        }
        aggregate: {
          args: Prisma.ContactAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateContact>
        }
        groupBy: {
          args: Prisma.ContactGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ContactGroupByOutputType>[]
        }
        count: {
          args: Prisma.ContactCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ContactCountAggregateOutputType> | number
        }
      }
    }
    Careers: {
      payload: Prisma.$CareersPayload<ExtArgs>
      fields: Prisma.CareersFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CareersFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareersPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CareersFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareersPayload>
        }
        findFirst: {
          args: Prisma.CareersFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareersPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CareersFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareersPayload>
        }
        findMany: {
          args: Prisma.CareersFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareersPayload>[]
        }
        create: {
          args: Prisma.CareersCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareersPayload>
        }
        createMany: {
          args: Prisma.CareersCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CareersCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareersPayload>[]
        }
        delete: {
          args: Prisma.CareersDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareersPayload>
        }
        update: {
          args: Prisma.CareersUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareersPayload>
        }
        deleteMany: {
          args: Prisma.CareersDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CareersUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CareersUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareersPayload>[]
        }
        upsert: {
          args: Prisma.CareersUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CareersPayload>
        }
        aggregate: {
          args: Prisma.CareersAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCareers>
        }
        groupBy: {
          args: Prisma.CareersGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CareersGroupByOutputType>[]
        }
        count: {
          args: Prisma.CareersCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CareersCountAggregateOutputType> | number
        }
      }
    }
    Realizations: {
      payload: Prisma.$RealizationsPayload<ExtArgs>
      fields: Prisma.RealizationsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RealizationsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RealizationsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RealizationsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RealizationsPayload>
        }
        findFirst: {
          args: Prisma.RealizationsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RealizationsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RealizationsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RealizationsPayload>
        }
        findMany: {
          args: Prisma.RealizationsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RealizationsPayload>[]
        }
        create: {
          args: Prisma.RealizationsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RealizationsPayload>
        }
        createMany: {
          args: Prisma.RealizationsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RealizationsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RealizationsPayload>[]
        }
        delete: {
          args: Prisma.RealizationsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RealizationsPayload>
        }
        update: {
          args: Prisma.RealizationsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RealizationsPayload>
        }
        deleteMany: {
          args: Prisma.RealizationsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RealizationsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RealizationsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RealizationsPayload>[]
        }
        upsert: {
          args: Prisma.RealizationsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RealizationsPayload>
        }
        aggregate: {
          args: Prisma.RealizationsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRealizations>
        }
        groupBy: {
          args: Prisma.RealizationsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RealizationsGroupByOutputType>[]
        }
        count: {
          args: Prisma.RealizationsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RealizationsCountAggregateOutputType> | number
        }
      }
    }
    GalleryItem: {
      payload: Prisma.$GalleryItemPayload<ExtArgs>
      fields: Prisma.GalleryItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GalleryItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GalleryItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GalleryItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GalleryItemPayload>
        }
        findFirst: {
          args: Prisma.GalleryItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GalleryItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GalleryItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GalleryItemPayload>
        }
        findMany: {
          args: Prisma.GalleryItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GalleryItemPayload>[]
        }
        create: {
          args: Prisma.GalleryItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GalleryItemPayload>
        }
        createMany: {
          args: Prisma.GalleryItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GalleryItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GalleryItemPayload>[]
        }
        delete: {
          args: Prisma.GalleryItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GalleryItemPayload>
        }
        update: {
          args: Prisma.GalleryItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GalleryItemPayload>
        }
        deleteMany: {
          args: Prisma.GalleryItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GalleryItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GalleryItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GalleryItemPayload>[]
        }
        upsert: {
          args: Prisma.GalleryItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GalleryItemPayload>
        }
        aggregate: {
          args: Prisma.GalleryItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGalleryItem>
        }
        groupBy: {
          args: Prisma.GalleryItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GalleryItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.GalleryItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GalleryItemCountAggregateOutputType> | number
        }
      }
    }
    Stat: {
      payload: Prisma.$StatPayload<ExtArgs>
      fields: Prisma.StatFieldRefs
      operations: {
        findUnique: {
          args: Prisma.StatFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.StatFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatPayload>
        }
        findFirst: {
          args: Prisma.StatFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.StatFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatPayload>
        }
        findMany: {
          args: Prisma.StatFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatPayload>[]
        }
        create: {
          args: Prisma.StatCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatPayload>
        }
        createMany: {
          args: Prisma.StatCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.StatCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatPayload>[]
        }
        delete: {
          args: Prisma.StatDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatPayload>
        }
        update: {
          args: Prisma.StatUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatPayload>
        }
        deleteMany: {
          args: Prisma.StatDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.StatUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.StatUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatPayload>[]
        }
        upsert: {
          args: Prisma.StatUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StatPayload>
        }
        aggregate: {
          args: Prisma.StatAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateStat>
        }
        groupBy: {
          args: Prisma.StatGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StatGroupByOutputType>[]
        }
        count: {
          args: Prisma.StatCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StatCountAggregateOutputType> | number
        }
      }
    }
    Location: {
      payload: Prisma.$LocationPayload<ExtArgs>
      fields: Prisma.LocationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LocationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocationPayload>
        }
        findFirst: {
          args: Prisma.LocationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocationPayload>
        }
        findMany: {
          args: Prisma.LocationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocationPayload>[]
        }
        create: {
          args: Prisma.LocationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocationPayload>
        }
        createMany: {
          args: Prisma.LocationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocationPayload>[]
        }
        delete: {
          args: Prisma.LocationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocationPayload>
        }
        update: {
          args: Prisma.LocationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocationPayload>
        }
        deleteMany: {
          args: Prisma.LocationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LocationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocationPayload>[]
        }
        upsert: {
          args: Prisma.LocationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LocationPayload>
        }
        aggregate: {
          args: Prisma.LocationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLocation>
        }
        groupBy: {
          args: Prisma.LocationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LocationGroupByOutputType>[]
        }
        count: {
          args: Prisma.LocationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LocationCountAggregateOutputType> | number
        }
      }
    }
    Service: {
      payload: Prisma.$ServicePayload<ExtArgs>
      fields: Prisma.ServiceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ServiceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        findFirst: {
          args: Prisma.ServiceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        findMany: {
          args: Prisma.ServiceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>[]
        }
        create: {
          args: Prisma.ServiceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        createMany: {
          args: Prisma.ServiceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>[]
        }
        delete: {
          args: Prisma.ServiceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        update: {
          args: Prisma.ServiceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        deleteMany: {
          args: Prisma.ServiceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ServiceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>[]
        }
        upsert: {
          args: Prisma.ServiceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePayload>
        }
        aggregate: {
          args: Prisma.ServiceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateService>
        }
        groupBy: {
          args: Prisma.ServiceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServiceGroupByOutputType>[]
        }
        count: {
          args: Prisma.ServiceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServiceCountAggregateOutputType> | number
        }
      }
    }
    StockItem: {
      payload: Prisma.$StockItemPayload<ExtArgs>
      fields: Prisma.StockItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.StockItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.StockItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockItemPayload>
        }
        findFirst: {
          args: Prisma.StockItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.StockItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockItemPayload>
        }
        findMany: {
          args: Prisma.StockItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockItemPayload>[]
        }
        create: {
          args: Prisma.StockItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockItemPayload>
        }
        createMany: {
          args: Prisma.StockItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.StockItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockItemPayload>[]
        }
        delete: {
          args: Prisma.StockItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockItemPayload>
        }
        update: {
          args: Prisma.StockItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockItemPayload>
        }
        deleteMany: {
          args: Prisma.StockItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.StockItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.StockItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockItemPayload>[]
        }
        upsert: {
          args: Prisma.StockItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockItemPayload>
        }
        aggregate: {
          args: Prisma.StockItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateStockItem>
        }
        groupBy: {
          args: Prisma.StockItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StockItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.StockItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StockItemCountAggregateOutputType> | number
        }
      }
    }
    StockCategory: {
      payload: Prisma.$StockCategoryPayload<ExtArgs>
      fields: Prisma.StockCategoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.StockCategoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockCategoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.StockCategoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockCategoryPayload>
        }
        findFirst: {
          args: Prisma.StockCategoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockCategoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.StockCategoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockCategoryPayload>
        }
        findMany: {
          args: Prisma.StockCategoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockCategoryPayload>[]
        }
        create: {
          args: Prisma.StockCategoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockCategoryPayload>
        }
        createMany: {
          args: Prisma.StockCategoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.StockCategoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockCategoryPayload>[]
        }
        delete: {
          args: Prisma.StockCategoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockCategoryPayload>
        }
        update: {
          args: Prisma.StockCategoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockCategoryPayload>
        }
        deleteMany: {
          args: Prisma.StockCategoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.StockCategoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.StockCategoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockCategoryPayload>[]
        }
        upsert: {
          args: Prisma.StockCategoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockCategoryPayload>
        }
        aggregate: {
          args: Prisma.StockCategoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateStockCategory>
        }
        groupBy: {
          args: Prisma.StockCategoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StockCategoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.StockCategoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StockCategoryCountAggregateOutputType> | number
        }
      }
    }
    Supplier: {
      payload: Prisma.$SupplierPayload<ExtArgs>
      fields: Prisma.SupplierFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SupplierFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>
        }
        findFirst: {
          args: Prisma.SupplierFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>
        }
        findMany: {
          args: Prisma.SupplierFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>[]
        }
        create: {
          args: Prisma.SupplierCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>
        }
        createMany: {
          args: Prisma.SupplierCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>[]
        }
        delete: {
          args: Prisma.SupplierDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>
        }
        update: {
          args: Prisma.SupplierUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>
        }
        deleteMany: {
          args: Prisma.SupplierDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SupplierUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SupplierUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>[]
        }
        upsert: {
          args: Prisma.SupplierUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SupplierPayload>
        }
        aggregate: {
          args: Prisma.SupplierAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSupplier>
        }
        groupBy: {
          args: Prisma.SupplierGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SupplierGroupByOutputType>[]
        }
        count: {
          args: Prisma.SupplierCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SupplierCountAggregateOutputType> | number
        }
      }
    }
    StockMovement: {
      payload: Prisma.$StockMovementPayload<ExtArgs>
      fields: Prisma.StockMovementFieldRefs
      operations: {
        findUnique: {
          args: Prisma.StockMovementFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockMovementPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.StockMovementFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockMovementPayload>
        }
        findFirst: {
          args: Prisma.StockMovementFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockMovementPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.StockMovementFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockMovementPayload>
        }
        findMany: {
          args: Prisma.StockMovementFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockMovementPayload>[]
        }
        create: {
          args: Prisma.StockMovementCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockMovementPayload>
        }
        createMany: {
          args: Prisma.StockMovementCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.StockMovementCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockMovementPayload>[]
        }
        delete: {
          args: Prisma.StockMovementDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockMovementPayload>
        }
        update: {
          args: Prisma.StockMovementUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockMovementPayload>
        }
        deleteMany: {
          args: Prisma.StockMovementDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.StockMovementUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.StockMovementUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockMovementPayload>[]
        }
        upsert: {
          args: Prisma.StockMovementUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockMovementPayload>
        }
        aggregate: {
          args: Prisma.StockMovementAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateStockMovement>
        }
        groupBy: {
          args: Prisma.StockMovementGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StockMovementGroupByOutputType>[]
        }
        count: {
          args: Prisma.StockMovementCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StockMovementCountAggregateOutputType> | number
        }
      }
    }
    StockMovementItem: {
      payload: Prisma.$StockMovementItemPayload<ExtArgs>
      fields: Prisma.StockMovementItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.StockMovementItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockMovementItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.StockMovementItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockMovementItemPayload>
        }
        findFirst: {
          args: Prisma.StockMovementItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockMovementItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.StockMovementItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockMovementItemPayload>
        }
        findMany: {
          args: Prisma.StockMovementItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockMovementItemPayload>[]
        }
        create: {
          args: Prisma.StockMovementItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockMovementItemPayload>
        }
        createMany: {
          args: Prisma.StockMovementItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.StockMovementItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockMovementItemPayload>[]
        }
        delete: {
          args: Prisma.StockMovementItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockMovementItemPayload>
        }
        update: {
          args: Prisma.StockMovementItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockMovementItemPayload>
        }
        deleteMany: {
          args: Prisma.StockMovementItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.StockMovementItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.StockMovementItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockMovementItemPayload>[]
        }
        upsert: {
          args: Prisma.StockMovementItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StockMovementItemPayload>
        }
        aggregate: {
          args: Prisma.StockMovementItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateStockMovementItem>
        }
        groupBy: {
          args: Prisma.StockMovementItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StockMovementItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.StockMovementItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StockMovementItemCountAggregateOutputType> | number
        }
      }
    }
    Payslip: {
      payload: Prisma.$PayslipPayload<ExtArgs>
      fields: Prisma.PayslipFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PayslipFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayslipPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PayslipFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayslipPayload>
        }
        findFirst: {
          args: Prisma.PayslipFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayslipPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PayslipFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayslipPayload>
        }
        findMany: {
          args: Prisma.PayslipFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayslipPayload>[]
        }
        create: {
          args: Prisma.PayslipCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayslipPayload>
        }
        createMany: {
          args: Prisma.PayslipCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PayslipCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayslipPayload>[]
        }
        delete: {
          args: Prisma.PayslipDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayslipPayload>
        }
        update: {
          args: Prisma.PayslipUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayslipPayload>
        }
        deleteMany: {
          args: Prisma.PayslipDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PayslipUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PayslipUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayslipPayload>[]
        }
        upsert: {
          args: Prisma.PayslipUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayslipPayload>
        }
        aggregate: {
          args: Prisma.PayslipAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePayslip>
        }
        groupBy: {
          args: Prisma.PayslipGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayslipGroupByOutputType>[]
        }
        count: {
          args: Prisma.PayslipCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayslipCountAggregateOutputType> | number
        }
      }
    }
    AccountingEntry: {
      payload: Prisma.$AccountingEntryPayload<ExtArgs>
      fields: Prisma.AccountingEntryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AccountingEntryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingEntryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AccountingEntryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingEntryPayload>
        }
        findFirst: {
          args: Prisma.AccountingEntryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingEntryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AccountingEntryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingEntryPayload>
        }
        findMany: {
          args: Prisma.AccountingEntryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingEntryPayload>[]
        }
        create: {
          args: Prisma.AccountingEntryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingEntryPayload>
        }
        createMany: {
          args: Prisma.AccountingEntryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AccountingEntryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingEntryPayload>[]
        }
        delete: {
          args: Prisma.AccountingEntryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingEntryPayload>
        }
        update: {
          args: Prisma.AccountingEntryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingEntryPayload>
        }
        deleteMany: {
          args: Prisma.AccountingEntryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AccountingEntryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AccountingEntryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingEntryPayload>[]
        }
        upsert: {
          args: Prisma.AccountingEntryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountingEntryPayload>
        }
        aggregate: {
          args: Prisma.AccountingEntryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAccountingEntry>
        }
        groupBy: {
          args: Prisma.AccountingEntryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccountingEntryGroupByOutputType>[]
        }
        count: {
          args: Prisma.AccountingEntryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccountingEntryCountAggregateOutputType> | number
        }
      }
    }
    Quote: {
      payload: Prisma.$QuotePayload<ExtArgs>
      fields: Prisma.QuoteFieldRefs
      operations: {
        findUnique: {
          args: Prisma.QuoteFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuotePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.QuoteFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuotePayload>
        }
        findFirst: {
          args: Prisma.QuoteFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuotePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.QuoteFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuotePayload>
        }
        findMany: {
          args: Prisma.QuoteFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuotePayload>[]
        }
        create: {
          args: Prisma.QuoteCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuotePayload>
        }
        createMany: {
          args: Prisma.QuoteCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.QuoteCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuotePayload>[]
        }
        delete: {
          args: Prisma.QuoteDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuotePayload>
        }
        update: {
          args: Prisma.QuoteUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuotePayload>
        }
        deleteMany: {
          args: Prisma.QuoteDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.QuoteUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.QuoteUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuotePayload>[]
        }
        upsert: {
          args: Prisma.QuoteUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuotePayload>
        }
        aggregate: {
          args: Prisma.QuoteAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateQuote>
        }
        groupBy: {
          args: Prisma.QuoteGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuoteGroupByOutputType>[]
        }
        count: {
          args: Prisma.QuoteCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuoteCountAggregateOutputType> | number
        }
      }
    }
    QuoteItem: {
      payload: Prisma.$QuoteItemPayload<ExtArgs>
      fields: Prisma.QuoteItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.QuoteItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuoteItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.QuoteItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuoteItemPayload>
        }
        findFirst: {
          args: Prisma.QuoteItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuoteItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.QuoteItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuoteItemPayload>
        }
        findMany: {
          args: Prisma.QuoteItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuoteItemPayload>[]
        }
        create: {
          args: Prisma.QuoteItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuoteItemPayload>
        }
        createMany: {
          args: Prisma.QuoteItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.QuoteItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuoteItemPayload>[]
        }
        delete: {
          args: Prisma.QuoteItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuoteItemPayload>
        }
        update: {
          args: Prisma.QuoteItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuoteItemPayload>
        }
        deleteMany: {
          args: Prisma.QuoteItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.QuoteItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.QuoteItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuoteItemPayload>[]
        }
        upsert: {
          args: Prisma.QuoteItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QuoteItemPayload>
        }
        aggregate: {
          args: Prisma.QuoteItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateQuoteItem>
        }
        groupBy: {
          args: Prisma.QuoteItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuoteItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.QuoteItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QuoteItemCountAggregateOutputType> | number
        }
      }
    }
    ContactCrm: {
      payload: Prisma.$ContactCrmPayload<ExtArgs>
      fields: Prisma.ContactCrmFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ContactCrmFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactCrmPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ContactCrmFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactCrmPayload>
        }
        findFirst: {
          args: Prisma.ContactCrmFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactCrmPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ContactCrmFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactCrmPayload>
        }
        findMany: {
          args: Prisma.ContactCrmFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactCrmPayload>[]
        }
        create: {
          args: Prisma.ContactCrmCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactCrmPayload>
        }
        createMany: {
          args: Prisma.ContactCrmCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ContactCrmCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactCrmPayload>[]
        }
        delete: {
          args: Prisma.ContactCrmDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactCrmPayload>
        }
        update: {
          args: Prisma.ContactCrmUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactCrmPayload>
        }
        deleteMany: {
          args: Prisma.ContactCrmDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ContactCrmUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ContactCrmUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactCrmPayload>[]
        }
        upsert: {
          args: Prisma.ContactCrmUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ContactCrmPayload>
        }
        aggregate: {
          args: Prisma.ContactCrmAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateContactCrm>
        }
        groupBy: {
          args: Prisma.ContactCrmGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ContactCrmGroupByOutputType>[]
        }
        count: {
          args: Prisma.ContactCrmCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ContactCrmCountAggregateOutputType> | number
        }
      }
    }
    Deal: {
      payload: Prisma.$DealPayload<ExtArgs>
      fields: Prisma.DealFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DealFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DealFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPayload>
        }
        findFirst: {
          args: Prisma.DealFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DealFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPayload>
        }
        findMany: {
          args: Prisma.DealFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPayload>[]
        }
        create: {
          args: Prisma.DealCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPayload>
        }
        createMany: {
          args: Prisma.DealCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DealCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPayload>[]
        }
        delete: {
          args: Prisma.DealDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPayload>
        }
        update: {
          args: Prisma.DealUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPayload>
        }
        deleteMany: {
          args: Prisma.DealDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DealUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DealUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPayload>[]
        }
        upsert: {
          args: Prisma.DealUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DealPayload>
        }
        aggregate: {
          args: Prisma.DealAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDeal>
        }
        groupBy: {
          args: Prisma.DealGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DealGroupByOutputType>[]
        }
        count: {
          args: Prisma.DealCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DealCountAggregateOutputType> | number
        }
      }
    }
    JobOpening: {
      payload: Prisma.$JobOpeningPayload<ExtArgs>
      fields: Prisma.JobOpeningFieldRefs
      operations: {
        findUnique: {
          args: Prisma.JobOpeningFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobOpeningPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.JobOpeningFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobOpeningPayload>
        }
        findFirst: {
          args: Prisma.JobOpeningFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobOpeningPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.JobOpeningFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobOpeningPayload>
        }
        findMany: {
          args: Prisma.JobOpeningFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobOpeningPayload>[]
        }
        create: {
          args: Prisma.JobOpeningCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobOpeningPayload>
        }
        createMany: {
          args: Prisma.JobOpeningCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.JobOpeningCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobOpeningPayload>[]
        }
        delete: {
          args: Prisma.JobOpeningDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobOpeningPayload>
        }
        update: {
          args: Prisma.JobOpeningUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobOpeningPayload>
        }
        deleteMany: {
          args: Prisma.JobOpeningDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.JobOpeningUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.JobOpeningUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobOpeningPayload>[]
        }
        upsert: {
          args: Prisma.JobOpeningUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JobOpeningPayload>
        }
        aggregate: {
          args: Prisma.JobOpeningAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateJobOpening>
        }
        groupBy: {
          args: Prisma.JobOpeningGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.JobOpeningGroupByOutputType>[]
        }
        count: {
          args: Prisma.JobOpeningCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.JobOpeningCountAggregateOutputType> | number
        }
      }
    }
    Invoice: {
      payload: Prisma.$InvoicePayload<ExtArgs>
      fields: Prisma.InvoiceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        findFirst: {
          args: Prisma.InvoiceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        findMany: {
          args: Prisma.InvoiceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>[]
        }
        create: {
          args: Prisma.InvoiceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        createMany: {
          args: Prisma.InvoiceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>[]
        }
        delete: {
          args: Prisma.InvoiceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        update: {
          args: Prisma.InvoiceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        deleteMany: {
          args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>[]
        }
        upsert: {
          args: Prisma.InvoiceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoicePayload>
        }
        aggregate: {
          args: Prisma.InvoiceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvoice>
        }
        groupBy: {
          args: Prisma.InvoiceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceGroupByOutputType>[]
        }
        count: {
          args: Prisma.InvoiceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceCountAggregateOutputType> | number
        }
      }
    }
    InvoiceItem: {
      payload: Prisma.$InvoiceItemPayload<ExtArgs>
      fields: Prisma.InvoiceItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InvoiceItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InvoiceItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
        }
        findFirst: {
          args: Prisma.InvoiceItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InvoiceItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
        }
        findMany: {
          args: Prisma.InvoiceItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
        }
        create: {
          args: Prisma.InvoiceItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
        }
        createMany: {
          args: Prisma.InvoiceItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InvoiceItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
        }
        delete: {
          args: Prisma.InvoiceItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
        }
        update: {
          args: Prisma.InvoiceItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
        }
        deleteMany: {
          args: Prisma.InvoiceItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InvoiceItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InvoiceItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
        }
        upsert: {
          args: Prisma.InvoiceItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
        }
        aggregate: {
          args: Prisma.InvoiceItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvoiceItem>
        }
        groupBy: {
          args: Prisma.InvoiceItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.InvoiceItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvoiceItemCountAggregateOutputType> | number
        }
      }
    }
    Payment: {
      payload: Prisma.$PaymentPayload<ExtArgs>
      fields: Prisma.PaymentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PaymentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        findFirst: {
          args: Prisma.PaymentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        findMany: {
          args: Prisma.PaymentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>[]
        }
        create: {
          args: Prisma.PaymentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        createMany: {
          args: Prisma.PaymentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>[]
        }
        delete: {
          args: Prisma.PaymentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        update: {
          args: Prisma.PaymentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        deleteMany: {
          args: Prisma.PaymentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PaymentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>[]
        }
        upsert: {
          args: Prisma.PaymentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PaymentPayload>
        }
        aggregate: {
          args: Prisma.PaymentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePayment>
        }
        groupBy: {
          args: Prisma.PaymentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentGroupByOutputType>[]
        }
        count: {
          args: Prisma.PaymentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PaymentCountAggregateOutputType> | number
        }
      }
    }
    PurchaseOrder: {
      payload: Prisma.$PurchaseOrderPayload<ExtArgs>
      fields: Prisma.PurchaseOrderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PurchaseOrderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
        }
        findFirst: {
          args: Prisma.PurchaseOrderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PurchaseOrderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
        }
        findMany: {
          args: Prisma.PurchaseOrderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
        }
        create: {
          args: Prisma.PurchaseOrderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
        }
        createMany: {
          args: Prisma.PurchaseOrderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PurchaseOrderCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
        }
        delete: {
          args: Prisma.PurchaseOrderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
        }
        update: {
          args: Prisma.PurchaseOrderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
        }
        deleteMany: {
          args: Prisma.PurchaseOrderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PurchaseOrderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
        }
        upsert: {
          args: Prisma.PurchaseOrderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
        }
        aggregate: {
          args: Prisma.PurchaseOrderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePurchaseOrder>
        }
        groupBy: {
          args: Prisma.PurchaseOrderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PurchaseOrderGroupByOutputType>[]
        }
        count: {
          args: Prisma.PurchaseOrderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PurchaseOrderCountAggregateOutputType> | number
        }
      }
    }
    PurchaseOrderItem: {
      payload: Prisma.$PurchaseOrderItemPayload<ExtArgs>
      fields: Prisma.PurchaseOrderItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PurchaseOrderItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PurchaseOrderItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
        }
        findFirst: {
          args: Prisma.PurchaseOrderItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PurchaseOrderItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
        }
        findMany: {
          args: Prisma.PurchaseOrderItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
        }
        create: {
          args: Prisma.PurchaseOrderItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
        }
        createMany: {
          args: Prisma.PurchaseOrderItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PurchaseOrderItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
        }
        delete: {
          args: Prisma.PurchaseOrderItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
        }
        update: {
          args: Prisma.PurchaseOrderItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
        }
        deleteMany: {
          args: Prisma.PurchaseOrderItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PurchaseOrderItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PurchaseOrderItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>[]
        }
        upsert: {
          args: Prisma.PurchaseOrderItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurchaseOrderItemPayload>
        }
        aggregate: {
          args: Prisma.PurchaseOrderItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePurchaseOrderItem>
        }
        groupBy: {
          args: Prisma.PurchaseOrderItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PurchaseOrderItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.PurchaseOrderItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PurchaseOrderItemCountAggregateOutputType> | number
        }
      }
    }
    Attendance: {
      payload: Prisma.$AttendancePayload<ExtArgs>
      fields: Prisma.AttendanceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        findFirst: {
          args: Prisma.AttendanceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        findMany: {
          args: Prisma.AttendanceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>[]
        }
        create: {
          args: Prisma.AttendanceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        createMany: {
          args: Prisma.AttendanceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>[]
        }
        delete: {
          args: Prisma.AttendanceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        update: {
          args: Prisma.AttendanceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        deleteMany: {
          args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AttendanceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>[]
        }
        upsert: {
          args: Prisma.AttendanceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        aggregate: {
          args: Prisma.AttendanceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAttendance>
        }
        groupBy: {
          args: Prisma.AttendanceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AttendanceGroupByOutputType>[]
        }
        count: {
          args: Prisma.AttendanceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AttendanceCountAggregateOutputType> | number
        }
      }
    }
    LeaveRequest: {
      payload: Prisma.$LeaveRequestPayload<ExtArgs>
      fields: Prisma.LeaveRequestFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LeaveRequestFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LeaveRequestFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
        }
        findFirst: {
          args: Prisma.LeaveRequestFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LeaveRequestFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
        }
        findMany: {
          args: Prisma.LeaveRequestFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
        }
        create: {
          args: Prisma.LeaveRequestCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
        }
        createMany: {
          args: Prisma.LeaveRequestCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LeaveRequestCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
        }
        delete: {
          args: Prisma.LeaveRequestDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
        }
        update: {
          args: Prisma.LeaveRequestUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
        }
        deleteMany: {
          args: Prisma.LeaveRequestDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LeaveRequestUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LeaveRequestUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
        }
        upsert: {
          args: Prisma.LeaveRequestUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
        }
        aggregate: {
          args: Prisma.LeaveRequestAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLeaveRequest>
        }
        groupBy: {
          args: Prisma.LeaveRequestGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeaveRequestGroupByOutputType>[]
        }
        count: {
          args: Prisma.LeaveRequestCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeaveRequestCountAggregateOutputType> | number
        }
      }
    }
    Task: {
      payload: Prisma.$TaskPayload<ExtArgs>
      fields: Prisma.TaskFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TaskFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>
        }
        findFirst: {
          args: Prisma.TaskFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>
        }
        findMany: {
          args: Prisma.TaskFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>[]
        }
        create: {
          args: Prisma.TaskCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>
        }
        createMany: {
          args: Prisma.TaskCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>[]
        }
        delete: {
          args: Prisma.TaskDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>
        }
        update: {
          args: Prisma.TaskUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>
        }
        deleteMany: {
          args: Prisma.TaskDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TaskUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>[]
        }
        upsert: {
          args: Prisma.TaskUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>
        }
        aggregate: {
          args: Prisma.TaskAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTask>
        }
        groupBy: {
          args: Prisma.TaskGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskGroupByOutputType>[]
        }
        count: {
          args: Prisma.TaskCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TaskCountAggregateOutputType> | number
        }
      }
    }
    Dictionary: {
      payload: Prisma.$DictionaryPayload<ExtArgs>
      fields: Prisma.DictionaryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DictionaryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DictionaryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DictionaryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DictionaryPayload>
        }
        findFirst: {
          args: Prisma.DictionaryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DictionaryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DictionaryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DictionaryPayload>
        }
        findMany: {
          args: Prisma.DictionaryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DictionaryPayload>[]
        }
        create: {
          args: Prisma.DictionaryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DictionaryPayload>
        }
        createMany: {
          args: Prisma.DictionaryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DictionaryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DictionaryPayload>[]
        }
        delete: {
          args: Prisma.DictionaryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DictionaryPayload>
        }
        update: {
          args: Prisma.DictionaryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DictionaryPayload>
        }
        deleteMany: {
          args: Prisma.DictionaryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DictionaryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DictionaryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DictionaryPayload>[]
        }
        upsert: {
          args: Prisma.DictionaryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DictionaryPayload>
        }
        aggregate: {
          args: Prisma.DictionaryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDictionary>
        }
        groupBy: {
          args: Prisma.DictionaryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DictionaryGroupByOutputType>[]
        }
        count: {
          args: Prisma.DictionaryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DictionaryCountAggregateOutputType> | number
        }
      }
    }
    PrinterSettings: {
      payload: Prisma.$PrinterSettingsPayload<ExtArgs>
      fields: Prisma.PrinterSettingsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PrinterSettingsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrinterSettingsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PrinterSettingsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrinterSettingsPayload>
        }
        findFirst: {
          args: Prisma.PrinterSettingsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrinterSettingsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PrinterSettingsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrinterSettingsPayload>
        }
        findMany: {
          args: Prisma.PrinterSettingsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrinterSettingsPayload>[]
        }
        create: {
          args: Prisma.PrinterSettingsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrinterSettingsPayload>
        }
        createMany: {
          args: Prisma.PrinterSettingsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PrinterSettingsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrinterSettingsPayload>[]
        }
        delete: {
          args: Prisma.PrinterSettingsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrinterSettingsPayload>
        }
        update: {
          args: Prisma.PrinterSettingsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrinterSettingsPayload>
        }
        deleteMany: {
          args: Prisma.PrinterSettingsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PrinterSettingsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PrinterSettingsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrinterSettingsPayload>[]
        }
        upsert: {
          args: Prisma.PrinterSettingsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrinterSettingsPayload>
        }
        aggregate: {
          args: Prisma.PrinterSettingsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePrinterSettings>
        }
        groupBy: {
          args: Prisma.PrinterSettingsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PrinterSettingsGroupByOutputType>[]
        }
        count: {
          args: Prisma.PrinterSettingsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PrinterSettingsCountAggregateOutputType> | number
        }
      }
    }
    AuditLog: {
      payload: Prisma.$AuditLogPayload<ExtArgs>
      fields: Prisma.AuditLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        findFirst: {
          args: Prisma.AuditLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        findMany: {
          args: Prisma.AuditLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        create: {
          args: Prisma.AuditLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        createMany: {
          args: Prisma.AuditLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        delete: {
          args: Prisma.AuditLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        update: {
          args: Prisma.AuditLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        deleteMany: {
          args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
        }
        upsert: {
          args: Prisma.AuditLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuditLogPayload>
        }
        aggregate: {
          args: Prisma.AuditLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAuditLog>
        }
        groupBy: {
          args: Prisma.AuditLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.AuditLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuditLogCountAggregateOutputType> | number
        }
      }
    }
    Webhook: {
      payload: Prisma.$WebhookPayload<ExtArgs>
      fields: Prisma.WebhookFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WebhookFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WebhookFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload>
        }
        findFirst: {
          args: Prisma.WebhookFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WebhookFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload>
        }
        findMany: {
          args: Prisma.WebhookFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload>[]
        }
        create: {
          args: Prisma.WebhookCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload>
        }
        createMany: {
          args: Prisma.WebhookCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WebhookCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload>[]
        }
        delete: {
          args: Prisma.WebhookDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload>
        }
        update: {
          args: Prisma.WebhookUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload>
        }
        deleteMany: {
          args: Prisma.WebhookDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WebhookUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WebhookUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload>[]
        }
        upsert: {
          args: Prisma.WebhookUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WebhookPayload>
        }
        aggregate: {
          args: Prisma.WebhookAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWebhook>
        }
        groupBy: {
          args: Prisma.WebhookGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WebhookGroupByOutputType>[]
        }
        count: {
          args: Prisma.WebhookCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WebhookCountAggregateOutputType> | number
        }
      }
    }
    ApiKey: {
      payload: Prisma.$ApiKeyPayload<ExtArgs>
      fields: Prisma.ApiKeyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        findFirst: {
          args: Prisma.ApiKeyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        findMany: {
          args: Prisma.ApiKeyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
        }
        create: {
          args: Prisma.ApiKeyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        createMany: {
          args: Prisma.ApiKeyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
        }
        delete: {
          args: Prisma.ApiKeyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        update: {
          args: Prisma.ApiKeyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        deleteMany: {
          args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ApiKeyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
        }
        upsert: {
          args: Prisma.ApiKeyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ApiKeyPayload>
        }
        aggregate: {
          args: Prisma.ApiKeyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateApiKey>
        }
        groupBy: {
          args: Prisma.ApiKeyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApiKeyGroupByOutputType>[]
        }
        count: {
          args: Prisma.ApiKeyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ApiKeyCountAggregateOutputType> | number
        }
      }
    }
    FileResource: {
      payload: Prisma.$FileResourcePayload<ExtArgs>
      fields: Prisma.FileResourceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FileResourceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileResourcePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FileResourceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileResourcePayload>
        }
        findFirst: {
          args: Prisma.FileResourceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileResourcePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FileResourceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileResourcePayload>
        }
        findMany: {
          args: Prisma.FileResourceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileResourcePayload>[]
        }
        create: {
          args: Prisma.FileResourceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileResourcePayload>
        }
        createMany: {
          args: Prisma.FileResourceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FileResourceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileResourcePayload>[]
        }
        delete: {
          args: Prisma.FileResourceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileResourcePayload>
        }
        update: {
          args: Prisma.FileResourceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileResourcePayload>
        }
        deleteMany: {
          args: Prisma.FileResourceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FileResourceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FileResourceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileResourcePayload>[]
        }
        upsert: {
          args: Prisma.FileResourceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FileResourcePayload>
        }
        aggregate: {
          args: Prisma.FileResourceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFileResource>
        }
        groupBy: {
          args: Prisma.FileResourceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FileResourceGroupByOutputType>[]
        }
        count: {
          args: Prisma.FileResourceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FileResourceCountAggregateOutputType> | number
        }
      }
    }
    Currency: {
      payload: Prisma.$CurrencyPayload<ExtArgs>
      fields: Prisma.CurrencyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CurrencyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CurrencyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>
        }
        findFirst: {
          args: Prisma.CurrencyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CurrencyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>
        }
        findMany: {
          args: Prisma.CurrencyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
        }
        create: {
          args: Prisma.CurrencyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>
        }
        createMany: {
          args: Prisma.CurrencyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CurrencyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
        }
        delete: {
          args: Prisma.CurrencyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>
        }
        update: {
          args: Prisma.CurrencyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>
        }
        deleteMany: {
          args: Prisma.CurrencyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CurrencyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CurrencyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>[]
        }
        upsert: {
          args: Prisma.CurrencyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CurrencyPayload>
        }
        aggregate: {
          args: Prisma.CurrencyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCurrency>
        }
        groupBy: {
          args: Prisma.CurrencyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CurrencyGroupByOutputType>[]
        }
        count: {
          args: Prisma.CurrencyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CurrencyCountAggregateOutputType> | number
        }
      }
    }
    ExchangeRate: {
      payload: Prisma.$ExchangeRatePayload<ExtArgs>
      fields: Prisma.ExchangeRateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ExchangeRateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ExchangeRateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
        }
        findFirst: {
          args: Prisma.ExchangeRateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ExchangeRateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
        }
        findMany: {
          args: Prisma.ExchangeRateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>[]
        }
        create: {
          args: Prisma.ExchangeRateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
        }
        createMany: {
          args: Prisma.ExchangeRateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ExchangeRateCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>[]
        }
        delete: {
          args: Prisma.ExchangeRateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
        }
        update: {
          args: Prisma.ExchangeRateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
        }
        deleteMany: {
          args: Prisma.ExchangeRateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ExchangeRateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ExchangeRateUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>[]
        }
        upsert: {
          args: Prisma.ExchangeRateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
        }
        aggregate: {
          args: Prisma.ExchangeRateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateExchangeRate>
        }
        groupBy: {
          args: Prisma.ExchangeRateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExchangeRateGroupByOutputType>[]
        }
        count: {
          args: Prisma.ExchangeRateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExchangeRateCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const UserScalarFieldEnum = {
  id: 'id',
  email: 'email',
  name: 'name',
  passwordHash: 'passwordHash',
  avatar: 'avatar',
  isVerified: 'isVerified',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  lastLogin: 'lastLogin',
  globalRole: 'globalRole',
  mfaEnabled: 'mfaEnabled',
  mfaSecret: 'mfaSecret'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const SessionScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  token: 'token',
  ipAddress: 'ipAddress',
  userAgent: 'userAgent',
  expiresAt: 'expiresAt',
  createdAt: 'createdAt'
} as const

export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


export const CompanyOwnerScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  companyId: 'companyId',
  role: 'role',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CompanyOwnerScalarFieldEnum = (typeof CompanyOwnerScalarFieldEnum)[keyof typeof CompanyOwnerScalarFieldEnum]


export const CompanyScalarFieldEnum = {
  id: 'id',
  entityName: 'entityName',
  country: 'country',
  currency: 'currency',
  flag: 'flag',
  slug: 'slug',
  logo: 'logo',
  activity: 'activity',
  sector: 'sector',
  legalForm: 'legalForm',
  capital: 'capital',
  ncc: 'ncc',
  rccm: 'rccm',
  manager: 'manager',
  tvaRate: 'tvaRate',
  address: 'address',
  city: 'city',
  bp: 'bp',
  phone: 'phone',
  email: 'email',
  primaryColor: 'primaryColor',
  secondaryColor: 'secondaryColor',
  domain: 'domain',
  status: 'status',
  subscriptionPlan: 'subscriptionPlan',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


export const EmployeeScalarFieldEnum = {
  id: 'id',
  matricule: 'matricule',
  fullName: 'fullName',
  position: 'position',
  department: 'department',
  email: 'email',
  phone: 'phone',
  address: 'address',
  baseSalary: 'baseSalary',
  status: 'status',
  contractType: 'contractType',
  userId: 'userId',
  companyId: 'companyId',
  role: 'role',
  accessLevel: 'accessLevel',
  temporaryPassword: 'temporaryPassword',
  temporaryPasswordExpiresAt: 'temporaryPasswordExpiresAt',
  lastLogin: 'lastLogin',
  joinDate: 'joinDate',
  leaveDate: 'leaveDate',
  faceDescriptor: 'faceDescriptor',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  roleId: 'roleId'
} as const

export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


export const PermissionScalarFieldEnum = {
  id: 'id',
  code: 'code',
  name: 'name',
  description: 'description',
  category: 'category',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


export const RoleScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  level: 'level',
  isDefault: 'isDefault',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


export const RolePermissionScalarFieldEnum = {
  id: 'id',
  roleId: 'roleId',
  permissionId: 'permissionId',
  createdAt: 'createdAt'
} as const

export type RolePermissionScalarFieldEnum = (typeof RolePermissionScalarFieldEnum)[keyof typeof RolePermissionScalarFieldEnum]


export const SeoScalarFieldEnum = {
  id: 'id',
  metaTitle: 'metaTitle',
  metaDescription: 'metaDescription',
  metaKeywords: 'metaKeywords',
  ogImage: 'ogImage',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SeoScalarFieldEnum = (typeof SeoScalarFieldEnum)[keyof typeof SeoScalarFieldEnum]


export const HeroScalarFieldEnum = {
  id: 'id',
  title: 'title',
  subtitle: 'subtitle',
  tagline: 'tagline',
  imageUrl: 'imageUrl',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type HeroScalarFieldEnum = (typeof HeroScalarFieldEnum)[keyof typeof HeroScalarFieldEnum]


export const AboutScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  vision: 'vision',
  mission: 'mission',
  values: 'values',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AboutScalarFieldEnum = (typeof AboutScalarFieldEnum)[keyof typeof AboutScalarFieldEnum]


export const ContactScalarFieldEnum = {
  id: 'id',
  email: 'email',
  phone: 'phone',
  address: 'address',
  hours: 'hours',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


export const CareersScalarFieldEnum = {
  id: 'id',
  title: 'title',
  subtitle: 'subtitle',
  description: 'description',
  contactEmail: 'contactEmail',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CareersScalarFieldEnum = (typeof CareersScalarFieldEnum)[keyof typeof CareersScalarFieldEnum]


export const RealizationsScalarFieldEnum = {
  id: 'id',
  works: 'works',
  clients: 'clients',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RealizationsScalarFieldEnum = (typeof RealizationsScalarFieldEnum)[keyof typeof RealizationsScalarFieldEnum]


export const GalleryItemScalarFieldEnum = {
  id: 'id',
  caption: 'caption',
  category: 'category',
  imageUrl: 'imageUrl',
  realizationsId: 'realizationsId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type GalleryItemScalarFieldEnum = (typeof GalleryItemScalarFieldEnum)[keyof typeof GalleryItemScalarFieldEnum]


export const StatScalarFieldEnum = {
  id: 'id',
  value: 'value',
  label: 'label',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type StatScalarFieldEnum = (typeof StatScalarFieldEnum)[keyof typeof StatScalarFieldEnum]


export const LocationScalarFieldEnum = {
  id: 'id',
  country: 'country',
  flag: 'flag',
  year: 'year',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


export const ServiceScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  iconName: 'iconName',
  features: 'features',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


export const StockItemScalarFieldEnum = {
  id: 'id',
  type: 'type',
  ref: 'ref',
  barcode: 'barcode',
  name: 'name',
  description: 'description',
  brand: 'brand',
  category: 'category',
  categoryId: 'categoryId',
  supplierId: 'supplierId',
  quantity: 'quantity',
  unit: 'unit',
  minThreshold: 'minThreshold',
  location: 'location',
  value: 'value',
  sellingPrice: 'sellingPrice',
  status: 'status',
  imageUrl: 'imageUrl',
  batchNumber: 'batchNumber',
  expiryDate: 'expiryDate',
  manufacturingDate: 'manufacturingDate',
  companyId: 'companyId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type StockItemScalarFieldEnum = (typeof StockItemScalarFieldEnum)[keyof typeof StockItemScalarFieldEnum]


export const StockCategoryScalarFieldEnum = {
  id: 'id',
  name: 'name',
  companyId: 'companyId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type StockCategoryScalarFieldEnum = (typeof StockCategoryScalarFieldEnum)[keyof typeof StockCategoryScalarFieldEnum]


export const SupplierScalarFieldEnum = {
  id: 'id',
  name: 'name',
  contactName: 'contactName',
  email: 'email',
  phone: 'phone',
  address: 'address',
  category: 'category',
  companyId: 'companyId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


export const StockMovementScalarFieldEnum = {
  id: 'id',
  type: 'type',
  reference: 'reference',
  date: 'date',
  partnerId: 'partnerId',
  partnerName: 'partnerName',
  status: 'status',
  totalValue: 'totalValue',
  companyId: 'companyId',
  supplierId: 'supplierId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type StockMovementScalarFieldEnum = (typeof StockMovementScalarFieldEnum)[keyof typeof StockMovementScalarFieldEnum]


export const StockMovementItemScalarFieldEnum = {
  id: 'id',
  stockMovementId: 'stockMovementId',
  stockItemId: 'stockItemId',
  description: 'description',
  quantity: 'quantity',
  unitPrice: 'unitPrice',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type StockMovementItemScalarFieldEnum = (typeof StockMovementItemScalarFieldEnum)[keyof typeof StockMovementItemScalarFieldEnum]


export const PayslipScalarFieldEnum = {
  id: 'id',
  employeeId: 'employeeId',
  employeeName: 'employeeName',
  period: 'period',
  date: 'date',
  baseSalary: 'baseSalary',
  transportPrime: 'transportPrime',
  housingPrime: 'housingPrime',
  otherBonuses: 'otherBonuses',
  grossSalary: 'grossSalary',
  cnpsDeduction: 'cnpsDeduction',
  taxDeduction: 'taxDeduction',
  otherDeductions: 'otherDeductions',
  netSalary: 'netSalary',
  status: 'status',
  companyId: 'companyId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PayslipScalarFieldEnum = (typeof PayslipScalarFieldEnum)[keyof typeof PayslipScalarFieldEnum]


export const AccountingEntryScalarFieldEnum = {
  id: 'id',
  date: 'date',
  ref: 'ref',
  label: 'label',
  category: 'category',
  amount: 'amount',
  type: 'type',
  status: 'status',
  companyId: 'companyId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AccountingEntryScalarFieldEnum = (typeof AccountingEntryScalarFieldEnum)[keyof typeof AccountingEntryScalarFieldEnum]


export const QuoteScalarFieldEnum = {
  id: 'id',
  reference: 'reference',
  clientId: 'clientId',
  clientName: 'clientName',
  date: 'date',
  validUntil: 'validUntil',
  status: 'status',
  totalAmount: 'totalAmount',
  companyId: 'companyId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  contactCrmId: 'contactCrmId'
} as const

export type QuoteScalarFieldEnum = (typeof QuoteScalarFieldEnum)[keyof typeof QuoteScalarFieldEnum]


export const QuoteItemScalarFieldEnum = {
  id: 'id',
  quoteId: 'quoteId',
  description: 'description',
  quantity: 'quantity',
  unitPrice: 'unitPrice',
  total: 'total',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type QuoteItemScalarFieldEnum = (typeof QuoteItemScalarFieldEnum)[keyof typeof QuoteItemScalarFieldEnum]


export const ContactCrmScalarFieldEnum = {
  id: 'id',
  companyName: 'companyName',
  contactName: 'contactName',
  email: 'email',
  phone: 'phone',
  address: 'address',
  type: 'type',
  status: 'status',
  lastContact: 'lastContact',
  industry: 'industry',
  companyId: 'companyId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ContactCrmScalarFieldEnum = (typeof ContactCrmScalarFieldEnum)[keyof typeof ContactCrmScalarFieldEnum]


export const DealScalarFieldEnum = {
  id: 'id',
  title: 'title',
  contactId: 'contactId',
  amount: 'amount',
  stage: 'stage',
  probability: 'probability',
  closingDate: 'closingDate',
  companyId: 'companyId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DealScalarFieldEnum = (typeof DealScalarFieldEnum)[keyof typeof DealScalarFieldEnum]


export const JobOpeningScalarFieldEnum = {
  id: 'id',
  title: 'title',
  location: 'location',
  type: 'type',
  description: 'description',
  status: 'status',
  careersId: 'careersId',
  companyId: 'companyId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type JobOpeningScalarFieldEnum = (typeof JobOpeningScalarFieldEnum)[keyof typeof JobOpeningScalarFieldEnum]


export const InvoiceScalarFieldEnum = {
  id: 'id',
  reference: 'reference',
  clientId: 'clientId',
  clientName: 'clientName',
  date: 'date',
  dueDate: 'dueDate',
  status: 'status',
  totalAmount: 'totalAmount',
  paidAmount: 'paidAmount',
  companyId: 'companyId',
  quoteId: 'quoteId',
  contactCrmId: 'contactCrmId',
  approvedById: 'approvedById',
  approvedAt: 'approvedAt',
  approvalNote: 'approvalNote',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


export const InvoiceItemScalarFieldEnum = {
  id: 'id',
  invoiceId: 'invoiceId',
  description: 'description',
  quantity: 'quantity',
  unitPrice: 'unitPrice',
  total: 'total',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type InvoiceItemScalarFieldEnum = (typeof InvoiceItemScalarFieldEnum)[keyof typeof InvoiceItemScalarFieldEnum]


export const PaymentScalarFieldEnum = {
  id: 'id',
  reference: 'reference',
  amount: 'amount',
  date: 'date',
  method: 'method',
  notes: 'notes',
  invoiceId: 'invoiceId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


export const PurchaseOrderScalarFieldEnum = {
  id: 'id',
  reference: 'reference',
  date: 'date',
  expectedDate: 'expectedDate',
  status: 'status',
  totalAmount: 'totalAmount',
  companyId: 'companyId',
  supplierId: 'supplierId',
  approvedById: 'approvedById',
  approvedAt: 'approvedAt',
  approvalNote: 'approvalNote',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PurchaseOrderScalarFieldEnum = (typeof PurchaseOrderScalarFieldEnum)[keyof typeof PurchaseOrderScalarFieldEnum]


export const PurchaseOrderItemScalarFieldEnum = {
  id: 'id',
  purchaseOrderId: 'purchaseOrderId',
  stockItemId: 'stockItemId',
  description: 'description',
  quantity: 'quantity',
  unitPrice: 'unitPrice',
  total: 'total',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PurchaseOrderItemScalarFieldEnum = (typeof PurchaseOrderItemScalarFieldEnum)[keyof typeof PurchaseOrderItemScalarFieldEnum]


export const AttendanceScalarFieldEnum = {
  id: 'id',
  date: 'date',
  checkIn: 'checkIn',
  checkOut: 'checkOut',
  status: 'status',
  notes: 'notes',
  employeeId: 'employeeId',
  companyId: 'companyId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


export const LeaveRequestScalarFieldEnum = {
  id: 'id',
  type: 'type',
  startDate: 'startDate',
  endDate: 'endDate',
  reason: 'reason',
  status: 'status',
  approvedAt: 'approvedAt',
  employeeId: 'employeeId',
  companyId: 'companyId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LeaveRequestScalarFieldEnum = (typeof LeaveRequestScalarFieldEnum)[keyof typeof LeaveRequestScalarFieldEnum]


export const TaskScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  priority: 'priority',
  status: 'status',
  dueDate: 'dueDate',
  assignedToId: 'assignedToId',
  clientId: 'clientId',
  supplierId: 'supplierId',
  productId: 'productId',
  category: 'category',
  tags: 'tags',
  startDate: 'startDate',
  completedAt: 'completedAt',
  estimatedHours: 'estimatedHours',
  actualHours: 'actualHours',
  companyId: 'companyId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


export const DictionaryScalarFieldEnum = {
  id: 'id',
  type: 'type',
  value: 'value',
  code: 'code',
  color: 'color',
  companyId: 'companyId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DictionaryScalarFieldEnum = (typeof DictionaryScalarFieldEnum)[keyof typeof DictionaryScalarFieldEnum]


export const PrinterSettingsScalarFieldEnum = {
  id: 'id',
  documentPrinter: 'documentPrinter',
  barcodePrinter: 'barcodePrinter',
  labelWidth: 'labelWidth',
  labelHeight: 'labelHeight',
  companyId: 'companyId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PrinterSettingsScalarFieldEnum = (typeof PrinterSettingsScalarFieldEnum)[keyof typeof PrinterSettingsScalarFieldEnum]


export const AuditLogScalarFieldEnum = {
  id: 'id',
  action: 'action',
  entity: 'entity',
  entityId: 'entityId',
  oldValue: 'oldValue',
  newValue: 'newValue',
  ipAddress: 'ipAddress',
  userAgent: 'userAgent',
  userId: 'userId',
  companyId: 'companyId',
  createdAt: 'createdAt'
} as const

export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


export const WebhookScalarFieldEnum = {
  id: 'id',
  url: 'url',
  events: 'events',
  isActive: 'isActive',
  secret: 'secret',
  companyId: 'companyId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type WebhookScalarFieldEnum = (typeof WebhookScalarFieldEnum)[keyof typeof WebhookScalarFieldEnum]


export const ApiKeyScalarFieldEnum = {
  id: 'id',
  name: 'name',
  key: 'key',
  isActive: 'isActive',
  lastUsedAt: 'lastUsedAt',
  expiresAt: 'expiresAt',
  companyId: 'companyId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


export const FileResourceScalarFieldEnum = {
  id: 'id',
  name: 'name',
  path: 'path',
  mimeType: 'mimeType',
  size: 'size',
  version: 'version',
  tags: 'tags',
  ocrContent: 'ocrContent',
  parentId: 'parentId',
  companyId: 'companyId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FileResourceScalarFieldEnum = (typeof FileResourceScalarFieldEnum)[keyof typeof FileResourceScalarFieldEnum]


export const CurrencyScalarFieldEnum = {
  id: 'id',
  code: 'code',
  symbol: 'symbol',
  name: 'name',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CurrencyScalarFieldEnum = (typeof CurrencyScalarFieldEnum)[keyof typeof CurrencyScalarFieldEnum]


export const ExchangeRateScalarFieldEnum = {
  id: 'id',
  fromCurrencyId: 'fromCurrencyId',
  toCurrencyId: 'toCurrencyId',
  rate: 'rate',
  date: 'date',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ExchangeRateScalarFieldEnum = (typeof ExchangeRateScalarFieldEnum)[keyof typeof ExchangeRateScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'GlobalRole'
 */
export type EnumGlobalRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GlobalRole'>
    


/**
 * Reference to a field of type 'GlobalRole[]'
 */
export type ListEnumGlobalRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GlobalRole[]'>
    


/**
 * Reference to a field of type 'CompanyRole'
 */
export type EnumCompanyRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyRole'>
    


/**
 * Reference to a field of type 'CompanyRole[]'
 */
export type ListEnumCompanyRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyRole[]'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


/**
 * Reference to a field of type 'CompanyStatus'
 */
export type EnumCompanyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyStatus'>
    


/**
 * Reference to a field of type 'CompanyStatus[]'
 */
export type ListEnumCompanyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyStatus[]'>
    


/**
 * Reference to a field of type 'SubscriptionPlan'
 */
export type EnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPlan'>
    


/**
 * Reference to a field of type 'SubscriptionPlan[]'
 */
export type ListEnumSubscriptionPlanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionPlan[]'>
    


/**
 * Reference to a field of type 'EmployeeStatus'
 */
export type EnumEmployeeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployeeStatus'>
    


/**
 * Reference to a field of type 'EmployeeStatus[]'
 */
export type ListEnumEmployeeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployeeStatus[]'>
    


/**
 * Reference to a field of type 'ContractType'
 */
export type EnumContractTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractType'>
    


/**
 * Reference to a field of type 'ContractType[]'
 */
export type ListEnumContractTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractType[]'>
    


/**
 * Reference to a field of type 'EmployeeRole'
 */
export type EnumEmployeeRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployeeRole'>
    


/**
 * Reference to a field of type 'EmployeeRole[]'
 */
export type ListEnumEmployeeRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployeeRole[]'>
    


/**
 * Reference to a field of type 'AccessLevel'
 */
export type EnumAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessLevel'>
    


/**
 * Reference to a field of type 'AccessLevel[]'
 */
export type ListEnumAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessLevel[]'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  user?: Prisma.UserOmit
  session?: Prisma.SessionOmit
  companyOwner?: Prisma.CompanyOwnerOmit
  company?: Prisma.CompanyOmit
  employee?: Prisma.EmployeeOmit
  permission?: Prisma.PermissionOmit
  role?: Prisma.RoleOmit
  rolePermission?: Prisma.RolePermissionOmit
  seo?: Prisma.SeoOmit
  hero?: Prisma.HeroOmit
  about?: Prisma.AboutOmit
  contact?: Prisma.ContactOmit
  careers?: Prisma.CareersOmit
  realizations?: Prisma.RealizationsOmit
  galleryItem?: Prisma.GalleryItemOmit
  stat?: Prisma.StatOmit
  location?: Prisma.LocationOmit
  service?: Prisma.ServiceOmit
  stockItem?: Prisma.StockItemOmit
  stockCategory?: Prisma.StockCategoryOmit
  supplier?: Prisma.SupplierOmit
  stockMovement?: Prisma.StockMovementOmit
  stockMovementItem?: Prisma.StockMovementItemOmit
  payslip?: Prisma.PayslipOmit
  accountingEntry?: Prisma.AccountingEntryOmit
  quote?: Prisma.QuoteOmit
  quoteItem?: Prisma.QuoteItemOmit
  contactCrm?: Prisma.ContactCrmOmit
  deal?: Prisma.DealOmit
  jobOpening?: Prisma.JobOpeningOmit
  invoice?: Prisma.InvoiceOmit
  invoiceItem?: Prisma.InvoiceItemOmit
  payment?: Prisma.PaymentOmit
  purchaseOrder?: Prisma.PurchaseOrderOmit
  purchaseOrderItem?: Prisma.PurchaseOrderItemOmit
  attendance?: Prisma.AttendanceOmit
  leaveRequest?: Prisma.LeaveRequestOmit
  task?: Prisma.TaskOmit
  dictionary?: Prisma.DictionaryOmit
  printerSettings?: Prisma.PrinterSettingsOmit
  auditLog?: Prisma.AuditLogOmit
  webhook?: Prisma.WebhookOmit
  apiKey?: Prisma.ApiKeyOmit
  fileResource?: Prisma.FileResourceOmit
  currency?: Prisma.CurrencyOmit
  exchangeRate?: Prisma.ExchangeRateOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

